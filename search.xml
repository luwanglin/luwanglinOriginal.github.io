<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>服务器搭建远程docker深度学习环境</title>
      <link href="/2020/08/18/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E8%BF%9C%E7%A8%8Bdocker%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/"/>
      <url>/2020/08/18/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E8%BF%9C%E7%A8%8Bdocker%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1 id="服务器搭建远程docker深度学习环境"><a href="#服务器搭建远程docker深度学习环境" class="headerlink" title="服务器搭建远程docker深度学习环境"></a>服务器搭建远程docker深度学习环境</h1><p>本文大部分内容参考知乎文章</p><p><a href="https://zhuanlan.zhihu.com/p/63426143">Docker+PyCharm快速搭建机器学习开发环境</a></p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>  Docker是一种容器技术，类似于虚拟机，但比虚拟机更轻便。Docker容器内的应用程序直接运行于宿主的内核，而没有自己的内核，而且也没有硬件虚拟。更多Docker的相关知识可以看《Docker-从入门到实践》。</p><h2 id="Deepo"><a href="#Deepo" class="headerlink" title="Deepo"></a>Deepo</h2><p><a href="https://link.zhihu.com/?target=https://github.com/ufoym/deepo">Deepo</a>是一个包含一系列Docker镜像的项目，这些镜像中包含了TensorFlow、Caffe和Torch等多种深度学习框架。也就是说，在这些镜像中已经包含了大部分流行的机器学习框架，只需要将镜像下载到本地，运行容器即可直接使用这些框架。<br>  Deepo提供了GPU和CPU版本的框架，这里使用的mac以CPU的镜像为例子，对于GPU版本的镜像需要先安装Nvidia官方的nividia-docker和相应版本的NVIDIA驱动。<br>  在github页面可以看到Deepo拥有众多的不同的镜像，以tag来区分，可以根据需要下载对应的镜像。这里以<code>docker pull ufoym/deepo</code>为例，这样会默认下载包含GPU版本的深度学习框架的镜像。</p><p>如果只想要使用CPU的环境的话可以在后面加上CPU，即<code>docker pull ufoym/deepo:cpu</code></p><h2 id="Deepo-ssh镜像"><a href="#Deepo-ssh镜像" class="headerlink" title="Deepo-ssh镜像"></a>Deepo-ssh镜像</h2><p>  在有了Deepo镜像之后，为了方便使用，可以在Deepo镜像基础上配置ssh服务，以便于mac通过ssh连接登录到容器，以及PyCharm调用远程的python的interpreter。<br>  登录到现有的Deepo容器，以<code>docker run -it ufoym/deepo:cpu bash</code>交互式的进入deepo容器中。<br><strong>配置容器ssh连接</strong>  这一步可以使用mac通过ssh连接ubuntu容器。首先通过<code>apt-get install openssh-server</code>用于开启ssh服务的外部连接。<br><strong>配置sshd</strong> 修改sshd的默认配置，编辑文件<code>/etc/ssh/sshd_config</code>，修改文件中的以下三行：</p><pre><code class="shell">PermitRootLogin yes # 可以登录 root 用户PubkeyAuthentication yes # 可以使用 ssh 公钥许可AuthorizedKeysFile  .ssh/authorized_keys # 公钥信息保存到该文件中</code></pre><p>​    我的配置文件<code>AuthorizedKeysFile  .ssh/authorized_keys</code>这一行有点不同，是这样的</p><pre><code class="shell"> AuthorizedKeysFile .ssh/authorized_keys .ssh/authorized_keys2</code></pre><p><strong>重启sshd</strong> <code>/etc/init.d/ssh restart</code>使得这些配置生效。<br><strong>添加你的机器的公钥到容器</strong> 这一步是为了能免密码ssh登录到容器中。</p><ol><li>在容器中<code>mkdir ~/.ssh</code></li><li><code>touch ~/.ssh/authorized_keys</code></li><li>在你自己的机器上新开一个终端窗口，<code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code>（替换为你自己的邮箱），会在<code>~/.ssh</code>目录下生成三个文件<code>id_rsa</code>、<code>id_rsa.pub</code>、<code>known_hosts</code>。复制<code>id_rsa.pub</code>文件中的内容。</li><li>将复制的内容粘贴到容器<code>~/.ssh/authorized_keys</code>文件中。</li></ol><p><strong>提交修改到镜像</strong> 以上对容器的修改并不会改变镜像文件，需要提交修改生成一个新的镜像。</p><ol><li><code>docker ps -a</code>查看刚刚使用deepo容器，记录下该容器的<code>CONTAINER ID</code>，例如<code>8b5a86d18e58</code>。</li><li><code>docker commit -m &#39;add ssh&#39; -a &#39;your-name&#39; 8b5a86d18e58 deepo-ssh</code>这样会将刚刚在deepo容器中配置的ssh服务保存，并生成新的deepo-ssh镜像。在后续使用<code>docker images</code>命令可以查看到新的镜像已经被保存。</li></ol><p><strong>运行最终的容器</strong><br><code>docker run -it -p 12622:22 -v ~/data:/data -v ~/config:/config deepo-ssh:1.0 /bin/bash &amp;&amp; /usr/sbin/sshd -D </code></p><p>如果想要运行GPU环境的话，那么必须在启动容器时加上<code>--runtime=nvidia</code>,那么此时的命令为：</p><p><code>docker run --runtime=nvidia -it -p 12622:22 -v ~/data:/data -v ~/config:/config deepo-ssh:1.0 /bin/bash &amp;&amp; /usr/sbin/sshd -D</code></p><ul><li><p>-d | 后台运行</p></li><li><p>-p 12622:22 | 绑定当前mac的12622端口到deepo-ssh容器的22端口（ssh服务默认为22端口）</p></li><li><pre><code class="shell"> -v ~/data:/data | 将本机上的~/data目录挂载到容器/data目录</code></pre></li><li><p>/usr/sbin/sshd -D | 容器运行的命令和参数，开启ssh服务 </p></li></ul><p>这样就可以通过<code>ssh -p 12622 root@localhost</code>连接到容器，可以进入python解释程序，执行<code>import torch</code>等命令查看机器学习框架是否能正常使用。在<code>exit</code>退出ssh连接后，容器仍运行在后台。</p><h2 id="ssh远程连接"><a href="#ssh远程连接" class="headerlink" title="ssh远程连接"></a>ssh远程连接</h2><p>首先明确的是容器中的22端口已经绑定到主机上的12622端口，那么此时如果想要远程连接的话那么应该采用如下命令：</p><pre><code class="shell">ssh -p 12622 root@&lt;你的主机的ip地址&gt;</code></pre><p>这里有个坑注意。如果你的服务器主机是内网的，要想正确访问的话，那么必须首先搭建隧道。可以参考我之前的博客文章，<a href="https://luwanglin.gitee.io/2020/08/08/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/">反向代理搭建隧道</a></p><ol><li>其中这里的坑就是<code>我用autossh搭建隧道不起作用，无法远程登录进行容器里面，但是使用ssh搭建的就可以正确访问</code></li></ol><p>其中ssh的命令为：<code>ssh -fCNR 2064:localhost:12622 &lt;公网机器上用来做转发的账户&gt;@&lt;你的公网机器的ip地址&gt;</code></p><p>具体的参数含义可以参考上面给出的文章链接。</p><p>这样就将公网机器上的<code>2064</code>端口给绑定到你的内网机器的12622端口上了（假定你的服务器是在内网的，这样通过反向代理就可以通过外网进行访问了），即通过ssh就可以进行远程登录容器了：</p><pre><code class="shell">ssh -p 2064 root@&lt;你的公网主机的ip地址&gt;</code></pre><ol start="2"><li>第二个坑就是ssh连接时的root的账户密码你是不知道的，因为如果像上面启动容器后你没有修改设置密码，你是不知道root的密码的，所以你需要在启动容器后再重新设置一下密码，这样ssh连接的时候才能正确登录。</li></ol><h2 id="基于之前的镜像重新编写Dockerfile，设置容器启动时的密码"><a href="#基于之前的镜像重新编写Dockerfile，设置容器启动时的密码" class="headerlink" title="基于之前的镜像重新编写Dockerfile，设置容器启动时的密码"></a>基于之前的镜像重新编写Dockerfile，设置容器启动时的密码</h2><ol><li><p>首先编写Dockerfile，由于之前已经提交过一次镜像，我们可以基于之前的镜像进行重新的构建一个新的镜像，这样设置里面的root的账户密码为自定义密码。在一个空目录下，创建Dockerfile文件，然后添加如下内容：</p><pre><code class="shell">FROM deepo-ssh:1.0RUN echo &quot;root:123456&quot; | chpasswd</code></pre><ul><li>deepo-ssh:1.0 是之前生成的镜像</li><li>echo “root:123456” | chpasswd 是将root的账户密码默认设置为123456了（这里密码你可以自行设置）</li></ul></li><li><p>然后再次构建镜像，在Dockerfile文件所在的目录执行如下命令：</p><pre><code class="shell">docker build -t deepo-ssh:2.0 .</code></pre><p>这样就创建了deepo-ssh:2.0的镜像，然后基于这个镜像启动容器root账户默认的密码既是你自己设置的了。</p></li><li><p>启动容器</p><p><code>docker run -it -p 12622:22 -v ~/data:/data -v ~/config:/config deepo-ssh:2.0 /bin/bash &amp;&amp; /usr/sbin/sshd -D </code></p><p>注意这里是<strong>deepo-ssh:2.0</strong></p><p>如果ssh连接不上容器 ，那么在容器中 重启一下ssh服务</p><pre><code class="shell">/etc/init.d/ssh restart</code></pre></li></ol><h1 id="PyCharm连接Docker"><a href="#PyCharm连接Docker" class="headerlink" title="PyCharm连接Docker"></a>PyCharm连接Docker</h1><p>     经过以上的操作，可以理解成本地12622端口开启了ssh服务，运行一个独立的ubuntu服务器。接下来介绍如何使用PyCharm调用Docker容器中的解释器。（注意需要PyCharm专业版）<br>   在Pycharm中file–&gt;settings–&gt;Project Interpreter，如下图所示：</p><p>​    然后点击Add进行添加python解释器</p><ul><li><img src="https://gitee.com/LuWangLin/picBed_new/raw/master/img/image-20200818111853045.png" alt="image-20200818111853045"></li></ul><p>然后选择你已经配置好的ssh连接，进行配置python解释器：</p><ul><li><img src="https://gitee.com/LuWangLin/picBed_new/raw/master/img/image-20200818112043431.png" alt="image-20200818112043431"></li></ul><p>接下里选择解释器，这里一定注意interpreter的地方，要选择正确；然后配置同步目录（即你的本地项目会同步到容器中的哪个目录）</p><ul><li><img src="https://gitee.com/LuWangLin/picBed_new/raw/master/img/image-20200818112414875.png" alt="image-20200818112414875"></li></ul><p>点击finish就配置完成了，接下来就可以进行本地开发，远程运行在容器里了。</p><p><code>注意这里的同步目录最好是之前设置的启动容器时挂载的目录,即最好在/data下</code>，这样容器销毁了数据也不会丢失</p><p>在服务器上创建docker容器并运行在后台，映射到服务器的一个端口。在Pycharm中调用远程服务器的解释器，并创建本地目录和服务器目录的映射（在Deployment配置），就可以实现在本地写代码和调试。</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>如果发现ssh连接不上，那么可以在容器内进行重启下ssh服务</p><pre><code class="shell">/etc/init.d/ssh restart</code></pre>]]></content>
      
      
      <categories>
          
          <category> 深度学习环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> pycharm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PicGo软件搭配gitee实现图床</title>
      <link href="/2020/08/16/PicGo%E8%BD%AF%E4%BB%B6%E6%90%AD%E9%85%8Dgitee%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%BA%8A/"/>
      <url>/2020/08/16/PicGo%E8%BD%AF%E4%BB%B6%E6%90%AD%E9%85%8Dgitee%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="1-安装PicGo软件，并配置gitee"><a href="#1-安装PicGo软件，并配置gitee" class="headerlink" title="1.安装PicGo软件，并配置gitee"></a>1.安装PicGo软件，并配置gitee</h1><h2 id="1-1安装picGo"><a href="#1-1安装picGo" class="headerlink" title="1.1安装picGo"></a>1.1安装picGo</h2><ul><li>picGo</li><li>安装gitee-uploader 插件</li></ul><p>官网下载地址如下：<a href="https://github.com/Molunerfinn/picgo/releases">最新版本</a></p><p>可以自行选择版本进行下载，这里我选择了最新的版本进行下载安装，由于我有梯子下载比较快，如果下载慢的话可以下载我上传到码云的最新安装包</p><blockquote><p><a href="https://gitee.com/LuWangLin/picBed_new/commit/9555004e3d75c6ee478fe1e38cba5ed7fa062318">最新安装包下载</a></p></blockquote><p>安装之后如下图：</p><p><img src="https://gitee.com/LuWangLin/picBed_new/raw/master/img/image-20200816113049838.png"></p><h2 id="1-2配置码云"><a href="#1-2配置码云" class="headerlink" title="1.2配置码云"></a>1.2配置码云</h2><ol><li><p>首先安装码云插件</p><p>点击picGo中的插件设置，然后输入gitee搜索插件，有两个插件都可用，自行选择，这里我选择的是第二个。</p><p><img src="https://gitee.com/LuWangLin/picBed_new/raw/master/img/image-20200816113420909.png"></p><p><code>这里需要注意的是你的电脑上必须有Nodejs环境，我这里已经之前安装过了Nodejs了，所以可以进行插件安装</code></p></li><li><p>建立gitee码云仓库来存储图片</p><p><img src="https://gitee.com/LuWangLin/picBed_new/raw/master/img/image-20200816210628472.png"></p><p>建立仓库注意要点：</p><ol><li>仓库要设置为公开</li><li><code>勾选使用readme文件初始化仓库</code>，这里是一个大坑，因为这几个插件都不会帮你自动创建master分支，我在配置完成后上传图片没报错，但是仓库里无论如何都不会上传到图片。</li></ol></li><li><p>接下来进行生成token，因为</p><ul><li><p>点击头像，进入设置</p><p><img src="https://gitee.com/LuWangLin/picBed_new/raw/master/img/image-20200816210710476.png"></p></li><li><p>找到右边安全设置里面的私人令牌</p><p><img src="https://gitee.com/LuWangLin/picBed_new/raw/master/img/image-20200816210735143.png"></p></li><li><p>点击<code>生成新令牌</code>，把<strong>projects</strong>这一项勾上，其他的不用勾，然后提交  </p><p><img src="https://gitee.com/LuWangLin/picBed_new/raw/master/img/image-20200816210805619.png"></p></li></ul></li></ol><p>   这里需要验证一下密码，验证密码之后会出来一串数字，这一串数字就是你的token，将这串数字复制到刚才的配置里面去。  </p><p>   <img src="https://gitee.com/LuWangLin/picBed_new/raw/master/img/20524049-3aa34ee5507a7d1d.jpg"></p><blockquote><p>注意：这个令牌只会明文显示一次，建议在配置插件的时候再来生成令牌，直接复制进去，搞丢了又要重新生成一个。</p></blockquote><h1 id="2-配置picGo和typora"><a href="#2-配置picGo和typora" class="headerlink" title="2. 配置picGo和typora"></a>2. 配置picGo和typora</h1><h2 id="2-1-配置picGo"><a href="#2-1-配置picGo" class="headerlink" title="2.1 配置picGo"></a>2.1 配置picGo</h2><p>​    <img src="https://gitee.com/LuWangLin/picBed_new/raw/master/img/image-20200816193026988.png"></p><ul><li><p>repo： 你的仓库地址，格式为 <code>你的账户名/仓库名</code></p><p>这个可以参考浏览器中的URL地址，比如我得这个图床仓库地址为：</p><p><img src="https://gitee.com/LuWangLin/picBed_new/raw/master/img/image-20200816193902468.png" alt="image-20200816193902468"></p><p>那么只需要复制我红色框标出的地方就可以了。</p></li><li><p>branch：默认为master分支，记住前面创建仓库时，一定要进行建立分支的初始化（即以勾选使用readme文件来初始化仓库），这里是一个坑</p><p><code>因为我开始一切都配置好了，而且上传图片的时候没有报错，但是仓库里就是没有看到上传的照片</code></p></li><li><p>token： 前面生成的token填入即可</p></li><li><p>path：这里选择是你保存图片的地址，不填的话是在仓库根目录下。这里可以自己随意设置个路径来保存图片</p></li><li><p>customPath和customUrl这里是根据自己备案的域名进行设置的，由于我没有备案的域名这里没有进行设置。</p></li></ul><p>接下来可以进行测试上传图片，picGo上传图片的使用方式，<a href="https://picgo.github.io/PicGo-Doc/zh/guide/">详细的可以参考官方教程</a></p><p>简单测试的话可以直接选择在上传区中拖拽文件：</p><p><img src="https://gitee.com/LuWangLin/picBed_new/raw/master/img/image-20200816113049838.png"></p><p>上传成功的话可以在仓库下的<code>img</code>文件夹下看到文件，默认的图片文件名格式为<code>image-时间日期格式</code>，这个去配置文件中进行修改。</p><h2 id="2-2配置typora"><a href="#2-2配置typora" class="headerlink" title="2.2配置typora"></a>2.2配置typora</h2><h3 id="typora整合picGo"><a href="#typora整合picGo" class="headerlink" title="typora整合picGo"></a>typora整合picGo</h3><p>更好的方式是，在写博客的时候，粘贴到typora中的图片能自动上传到gitee中。接下来就进行如下的配置：</p><p>在typora中，</p><blockquote><p>文件 -&gt;偏好设置 -&gt;图像</p></blockquote><p><img src="https://gitee.com/LuWangLin/picBed_new/raw/master/img/image-20200816200702234.png"></p><p>第五步进行测试看是否能够进行上传图片。</p><p><img src="https://gitee.com/LuWangLin/picBed_new/raw/master/img/image-20200816200806308.png"></p><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>接下来就是很方便进行博客的书写了，比如了要在文章中加入图片，直接复制之后，在typora中粘贴即可，这样typora自动就将图片上传到码云图床中了。</p><p>实在是太方便了，接下来就可以快乐写博客了。</p><h1 id="3-彩蛋"><a href="#3-彩蛋" class="headerlink" title="3.彩蛋"></a>3.彩蛋</h1><ol><li>利用picGo可以上传文件到仓库中，不仅仅可以上传图片，文章前面提供的安装包就是这样上传到码云中的，直接将安装包拖拽到picGo的上传区即可。</li><li>gitee仓库的容量有限制，如果图床仓库满了 ，可以按照上述过程再重新配置一个即可，但是token不用重新生成。</li></ol><h1 id="4-Gitee产品配额说明"><a href="#4-Gitee产品配额说明" class="headerlink" title="4.Gitee产品配额说明"></a>4.Gitee产品配额说明</h1><h2 id="社区版（个人用户）"><a href="#社区版（个人用户）" class="headerlink" title="社区版（个人用户）"></a>社区版（个人用户）</h2><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>仓库数量</td><td>创建 1000 个仓库，不限制公私有。</td></tr><tr><td>仓库容量</td><td>Git 单仓库容量上限为 500M ，SVN 单仓库容量上限为 400M 单文件最大 50M 用户总仓库容量为 5G 注：总仓库定义为用户名下以及所创建的组织下面的所有仓库。</td></tr><tr><td>附件容量</td><td>附件单文件大小上限为 100MB 单仓库附件总容量 1G</td></tr><tr><td>成员人数</td><td>公有仓库成员数量不限。 个人账号下所有私有仓库总的协作人数为 5人</td></tr></tbody></table><hr><h2 id="企业版"><a href="#企业版" class="headerlink" title="企业版"></a>企业版</h2><table><thead><tr><th>套餐</th><th>免费版</th><th>基础版</th><th>标准版</th><th>高级版</th><th>尊享版</th></tr></thead><tbody><tr><td>单仓库</td><td>最大 500 MB</td><td>最大 1 GB</td><td>最大 1 GB</td><td>最大 2 GB</td><td>最大 3 GB</td></tr><tr><td>单文件</td><td>最大 50 MB</td><td>最大 100 MB</td><td>最大 100 MB</td><td>最大 200 MB</td><td>最大 300 MB</td></tr></tbody></table><h1 id="5-参考文章"><a href="#5-参考文章" class="headerlink" title="5.参考文章"></a>5.参考文章</h1><ul><li><a href="https://juejin.im/post/6844904119732273165#comment">Typora+PicGo+Github/Gitee搭建免费稳定的图床</a></li><li><a href="https://www.jianshu.com/p/b69950a49ae2">PicGo + Gitee(码云)实现markdown图床</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 撰写博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> picGo </tag>
            
            <tag> 码云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具-Typora常用语法</title>
      <link href="/2020/08/16/%E5%B7%A5%E5%85%B7-Typora%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2020/08/16/%E5%B7%A5%E5%85%B7-Typora%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="工具-Typora常用语法"><a href="#工具-Typora常用语法" class="headerlink" title="工具-Typora常用语法"></a>工具-Typora常用语法</h1><blockquote><p>Markdown（MD）作为目前互联网写作相当流行的一种文档撰写语言格式，深受互联网编辑者的喜爱，由此周边一些基于MD的编辑工具也随之油然而生。</p><p>作为一款免费的MD编辑器：</p><ol><li>Typora极简、跨平台、且十分直观，无论写作还是阅读，都能让人一目了然</li><li>Typora的单窗口展示，优雅的实现了编辑与预览的一体化，颠覆了很多MD编辑器使用时编辑与预览分窗口显示的模式</li><li>并且Typora还具有多格式导出功能，方便快捷</li></ol><p>使用一段时间后，我也变成了Typora的青睐者，使写作编辑效率大大提高。</p></blockquote><p><img src="https://gitee.com/LuWangLin/picBed_new/raw/master/img/1.jpg" alt="img"></p><h2 id="文字类标注"><a href="#文字类标注" class="headerlink" title="文字类标注"></a>文字类标注</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><blockquote><p>标题是用<code>“#”</code>实现的，标题前面加一个<code>“#”</code>，代表一级标题；</p><p>依次类推，标题前面加六个<code>“#”</code>代表六级标题；</p><p>一共有六级标题，编辑各种文档完全够用。</p></blockquote><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><blockquote><p>快捷键 <code>Ctrl+u（或cmd+u）</code>，即可实现下划线功能 。</p></blockquote><h3 id="加粗强调"><a href="#加粗强调" class="headerlink" title="加粗强调"></a>加粗强调</h3><blockquote><p>在要强调内容前后分别加<code>两个“*”</code> 号或者<code>两个“_”</code>号。</p></blockquote><h3 id="文字背景强调"><a href="#文字背景强调" class="headerlink" title="文字背景强调"></a>文字背景强调</h3><blockquote><p>在要强调内容前后分别加一个 ` 号。</p></blockquote><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><blockquote><p>内容前后分别加<code>一个 “*”</code> 号。</p></blockquote><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><blockquote><p>先转化成英文输入法，再把内容前后分别加上 <code>两个“~”</code> 号。</p></blockquote><h3 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h3><blockquote><p>内容前后分别加<code>两个“=”</code>。</p></blockquote><h3 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h3><blockquote><p>上标使用<code>^</code>包裹，例如：<code>y^2^=4</code>将产生表达式</p></blockquote><h3 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h3><blockquote><p>下标使用<code>~</code>包裹，例如：<code>H~2~O</code>将产生水的分子式。</p></blockquote><hr><h2 id="列表-list"><a href="#列表-list" class="headerlink" title="列表 list"></a>列表 list</h2><h3 id="目录列表生成"><a href="#目录列表生成" class="headerlink" title="目录列表生成"></a>目录列表生成</h3><blockquote><p>输入 <code>[toc]</code> 然后回车，将会产生一个目录，这个目录抽取了文章的所有标题，自动更新内容。</p></blockquote><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><blockquote><p>输入数字<code>“1”</code>+<code>“.”</code>+<code>空格</code> ， 自动开始有序列表。</p><p>例如：</p><blockquote><pre><code>1. 吃饭2. 睡觉3. 打豆豆</code></pre></blockquote><p>生成内容：</p><blockquote><ol><li>吃饭</li><li>睡觉</li><li>打豆豆</li></ol></blockquote></blockquote><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><blockquote><p>输入<code>“+”</code>或<code>“-”</code>或<code>“*”</code>+<code>空格</code>，自动开始无序列表。</p><p>例如：</p><blockquote><pre><code>- 吃饭- 睡觉- 打豆豆</code></pre></blockquote><p>生成内容：</p><blockquote><ul><li>吃饭</li><li>睡觉</li><li>打豆豆</li></ul></blockquote></blockquote><h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><blockquote><p>使用如下的代码创建任务列表，在 <code>[]</code> 中输入 <code>x</code> 表示完成，也可以通过点击选择完成或者没完成。</p><p>例如：</p><blockquote><pre><code>- [ ] 吃饭- [ ] 睡觉- [x] 打豆豆</code></pre></blockquote><p>生成内容：</p><blockquote><ul><li>吃饭</li><li>睡觉</li><li>打豆豆</li></ul></blockquote></blockquote><h2 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h2><blockquote><p>使用 <code>&gt;</code> 来插入块引用。</p></blockquote><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>Ctrl+T（alt+cmd+T），在弹出的对话框中选择行列数，自动生成列表。 还可以很方便地对表格进行编辑。</p><table><thead><tr><th>标题1</th><th>标题2</th><th>标题3</th><th>标题4</th></tr></thead><tbody><tr><td>内容1-1</td><td>内容2-1</td><td>内容3-1</td><td>内容4-1</td></tr><tr><td>内容1-2</td><td>内容2-2</td><td>内容3-2</td><td>内容4-2</td></tr><tr><td>内容1-3</td><td>内容2-3</td><td>内容3-3</td><td>内容4-3</td></tr></tbody></table><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><blockquote><p>输入三个或三个以上<code>*</code>（或<code>-</code>），再按回车键，即出现一条分割线。</p><p>例如：<code>***</code>、<code>---</code></p></blockquote><hr><hr><h2 id="标注"><a href="#标注" class="headerlink" title="标注"></a>标注</h2><blockquote><p>我们可以对某一个词语进行标注。把鼠标放在<code>注释</code>上，将会有提示内容。</p><p>例如：</p><blockquote><pre><code>某些人用过了才知道[^注释][^注释]: Somebody that I used to know.</code></pre></blockquote><p>生成内容：</p><blockquote><p>某些人用过了才知道[<a href="https://juejin.im/post/6844903776755662855#fn1">1]</a></p></blockquote></blockquote><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><ul><li>插入本地图片：直接把图片拖入即可</li><li>插入网络图片: <code>[图片标题](图片链接)</code>。</li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><blockquote><p>使用方法： <code>[链接提示]+(链接地址)</code>。</p><p>例如： <code>[点此进入TYpora官网下载](https://typora.io/)</code></p><p>生成内容：<a href="https://typora.io/">点此进入TYpora官网下载</a></p></blockquote><h3 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h3><blockquote><p>“?”+回车。</p><p>例如：</p><blockquote><pre><code>?y=ax^2+bx+c?</code></pre><p>生成内容：</p><p><img src="https://juejin.im/equation?tex=y=ax%5E2+bx+c" alt="y=ax^2+bx+c"></p></blockquote></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul><li>行内代码：代码的两端各加一个 “ ` ” 号，（在Tab键上面，英文输入法）</li><li>代码块：输入三个<code>“~”</code>，按回车键，即可选择编程语言。</li></ul><h2 id="输出文件格式"><a href="#输出文件格式" class="headerlink" title="输出文件格式"></a>输出文件格式</h2><blockquote><p>Typora 的文件导入/导出功能使用 <a href="http://pandoc.org/installing.html">Pandoc</a> 把 Markdown 源码转换成不同的文件格式，所以我们如果想使用文件导入/导出功能，必须先安装 Pandoc。</p></blockquote><hr><h1 id="Typora-相关配置"><a href="#Typora-相关配置" class="headerlink" title="Typora 相关配置"></a>Typora 相关配置</h1><h2 id="md文件默认打开软件的配置"><a href="#md文件默认打开软件的配置" class="headerlink" title=".md文件默认打开软件的配置"></a>.md文件默认打开软件的配置</h2><blockquote><ul><li>找到一个<code>.md</code>格式的文件</li><li>右键／显示简介／打开方式／选择Typora.app ／全部更改 (如下图)</li></ul><p><img src="F:\桌面\学习笔记\博客搭建\myblog_gitee\博客笔记\2.jpg" alt="img"></p></blockquote><h2 id="下载Typora主题配置"><a href="#下载Typora主题配置" class="headerlink" title="下载Typora主题配置"></a>下载Typora主题配置</h2><blockquote><ul><li>在<a href="https://theme.typora.io/">Typora官网</a>下载喜欢的主题</li><li>打开typora的系统偏好设置／通用／打开主题文件夹，进入主题文件夹</li><li>将刚下载好的主题解压缩，拷贝主题文件到<code>主题文件夹</code>这个目录 (如下图)</li></ul><p><img src="https://gitee.com/LuWangLin/picBed_new/raw/master/img/3.jpg" alt="img"></p></blockquote><h2 id="允许Typora使用上标、下标等语法"><a href="#允许Typora使用上标、下标等语法" class="headerlink" title="允许Typora使用上标、下标等语法"></a>允许Typora使用上标、下标等语法</h2><blockquote><p>打开Typora的系统偏好设置／Markdown／选中希望展示的语法规则</p></blockquote><p><img src="https://gitee.com/LuWangLin/picBed_new/raw/master/img/4.jpg" alt="img"></p><h1 id="常用快捷方式-持续记载中"><a href="#常用快捷方式-持续记载中" class="headerlink" title="常用快捷方式(持续记载中)"></a>常用快捷方式(持续记载中)</h1><h2 id="格式化代码块"><a href="#格式化代码块" class="headerlink" title="格式化代码块"></a>格式化代码块</h2><p>粘贴代码块时，如果没有格式对齐，此时可以采用快捷键shift+enter（Windows下）进行格式化整理对齐。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><ul><li><a href="https://typora.io/">Typora官网</a></li><li><a href="http://pandoc.org/installing.html">pandoc</a></li></ul><hr><p><a href="http://www.markdown.cn/">markdown</a> 还有很多优秀的功能，例如：<a href="https://mermaidjs.github.io/">甘特图</a>、<a href="https://mermaidjs.github.io/">UML 图表</a>、<a href="http://flowchart.js.org/">FLowchart流程图</a></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://juejin.im/post/6844903776755662855">typora常用语法</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> typora </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown语法笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>boostrap栅格系统自适应的布局</title>
      <link href="/2020/08/16/boostrap%E6%A0%85%E6%A0%BC%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E7%9A%84%E5%B8%83%E5%B1%80/"/>
      <url>/2020/08/16/boostrap%E6%A0%85%E6%A0%BC%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E7%9A%84%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="1-栅格系统"><a href="#1-栅格系统" class="headerlink" title="1.栅格系统"></a>1.栅格系统</h1><p>​        Bootstrap是基于移动优先的原则开发的，使用了一系列的媒体查询（media queries）方法，为我们的布局和界面创建自适应的的分界点。这些分界点主要是基于视口宽度的最小值，并且当窗口视图改变的时候允许元素缩放。</p><p>(分界点大小：576px、768px、992px、1200px)</p><p>Bootstrap包含了一个强大的移动优先的网格系统，它是基于一个12列的布局、有5种响应尺寸(对应不同的屏幕)。Bootstrap4是完全基于flexbox流式布局构建的，完全支持响应式标准。</p><h1 id="2-响应式的class选择器"><a href="#2-响应式的class选择器" class="headerlink" title="2.响应式的class选择器"></a>2.响应式的class选择器</h1><p>​        Bootstrap的栅格系统包括五种宽带预定义，用于构建复杂的响应布局，你可以根据需要定义在特小<code>.col</code>、小<code>.col-sm-*</code>、中<code>.col-md-*</code>、大<code>.col-lg-*</code>、特大<code>.col-xl-*</code>五种屏幕(设备)下的样式。</p><p>​        每个标签都是定义了在当前断点之下的排列样式，一旦小于这个断点那么样式就不起作用了，变成了各独自占一行。</p><p><img src="https://gitee.com/LuWangLin/picBed_new/raw/master/img/image-20200816203236210.png" alt="image-20200816203236210"></p><p>类似于sm,md,lg,xl等都是断点，只有当屏幕尺寸大于断点的对应的大小，这样的的class样式才会生效。比如：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;!-- &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; --&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css&quot;          integrity=&quot;sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T&quot; crossorigin=&quot;anonymous&quot;&gt;    &lt;style&gt;        #box_row div &amp;#123;            line-height: 100px;            text-align: center        &amp;#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt;    &lt;div id=&quot;box_row&quot; class=&quot;row&quot; style=&quot;height: 100px&quot;&gt;        &lt;div class=&quot;col-xl-4&quot; style=&quot;background: #27ff86&quot;&gt;            222        &lt;/div&gt;        &lt;div class=&quot;col-xl-4 &quot; style=&quot;background: #8879ff&quot;&gt;            222        &lt;/div&gt;        &lt;div class=&quot;col-xl-4&quot; style=&quot;background: #ffc535&quot;&gt;            other        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>这里设置了边框，这里其实设置的在超大屏幕下的样式，即当前屏幕的尺寸宽度大于1140px时这个样式才生效，如下：</p><p><img src="https://i.loli.net/2020/08/16/lyQTtJx1GEZ9YLu.png"></p><p>但是当屏幕的尺寸变小之后，比如缩小到1140px之后，就会自动成为每列一行、水平堆砌。</p><p>比如把浏览器窗口的宽度调小到1140px以下，此时显示的效果如下：</p><p><img src="https://i.loli.net/2020/08/15/WQK15GClPzsJXEu.png" alt="image.png"></p><p>会自适应的进行布局，这是根据当前屏幕尺寸进行自动的调整的也就是说，当屏幕尺寸小于端点值xl时，此时每列就会自动的占一行，水平堆砌。</p><h1 id="3-混合布局"><a href="#3-混合布局" class="headerlink" title="3.混合布局"></a>3.混合布局</h1><pre><code class="html">&lt;div class=&quot;container&quot;&gt;    &lt;div id=&quot;box_row&quot; class=&quot;row&quot; style=&quot;height: 100px&quot;&gt;        &lt;div class=&quot;col-xl-4 col-sm-3&quot; style=&quot;background: #27ff86&quot;&gt;            222        &lt;/div&gt;        &lt;div class=&quot;col-xl-4 col-sm-3&quot; style=&quot;background: #8879ff&quot;&gt;            222        &lt;/div&gt;        &lt;div class=&quot;col-xl-4 col-sm-3&quot; style=&quot;background: #ffc535&quot;&gt;            other        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><p>这样就设置了两个断点，在超大屏幕下每块占4列，在大屏幕和小屏幕之间是占3列，以下是效果展示图：</p><ol><li><p>当屏幕尺寸大于1140px时，<code>col-xl-4</code>生效：</p><p><img src="https://i.loli.net/2020/08/16/lyQTtJx1GEZ9YLu.png"></p></li><li><p>当屏幕尺寸小于1140px，大于576px时：</p><p><img src="https://gitee.com/LuWangLin/picBed_new/raw/master/img/image-20200816111300036.png" alt="image-20200816111300036"></p><p>可以看到此时的布局调整到了<code>col-sm-3</code>下的自适应样式，即每个块占3列</p></li><li><p>混合布局情况下可以对多种设备进行布局调整。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Bootstrap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栅格系统 </tag>
            
            <tag> 混合布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo添加live2d,让你获得一个可爱的girlfriend</title>
      <link href="/2020/08/13/hexo%E6%B7%BB%E5%8A%A0live2d-%E8%AE%A9%E4%BD%A0%E8%8E%B7%E5%BE%97%E4%B8%80%E4%B8%AA%E5%8F%AF%E7%88%B1%E7%9A%84girlfriend/"/>
      <url>/2020/08/13/hexo%E6%B7%BB%E5%8A%A0live2d-%E8%AE%A9%E4%BD%A0%E8%8E%B7%E5%BE%97%E4%B8%80%E4%B8%AA%E5%8F%AF%E7%88%B1%E7%9A%84girlfriend/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装必备环境"><a href="#1-安装必备环境" class="headerlink" title="1.安装必备环境"></a>1.安装必备环境</h2><p>假定你已经有了hexo的一些环境，比如npm，node等</p><p>我的个人环境如下：</p><pre><code class="shell">$ node -vv12.18.3$ npm -v6.14.6</code></pre><p>本人博客的主题为：</p><blockquote><p>hexo-theme-matery</p></blockquote><h2 id="2-安装模块"><a href="#2-安装模块" class="headerlink" title="2.安装模块"></a>2.安装模块</h2><ol><li><p>首先进入博客的主目录下</p></li><li><p>执行以下命令进行安装live2D模块</p><pre><code class="shell">npm install --save hexo-helper-live2d</code></pre></li><li><p>这样进行安装后，我并没有进行相关的配置直接就可以在博客中看到可爱的动漫人物了</p><p>默认的人物是：</p><blockquote><p>shizuku</p></blockquote></li></ol><h2 id="3-修改默认配置，选择自己喜欢的人物"><a href="#3-修改默认配置，选择自己喜欢的人物" class="headerlink" title="3.修改默认配置，选择自己喜欢的人物"></a>3.修改默认配置，选择自己喜欢的人物</h2><p>   截图预览，参考作者的博客，以下为相关展示</p><h4 id="Epsilon2-1"><a href="#Epsilon2-1" class="headerlink" title="Epsilon2.1"></a>Epsilon2.1</h4><p>   <img src="/images/live2d/Epsilon2.1.gif" alt="img"></p><h4 id="Gantzert-Felixander"><a href="#Gantzert-Felixander" class="headerlink" title="Gantzert_Felixander"></a>Gantzert_Felixander</h4><p>   <img src="/images/live2d/Gantzert_Felixander.gif" alt="img"></p><h4 id="haru"><a href="#haru" class="headerlink" title="haru"></a>haru</h4><p>   <img src="/images/live2d/haru.gif" alt="img"></p><h4 id="miku"><a href="#miku" class="headerlink" title="miku"></a>miku</h4><p>   <img src="/images/live2d/miku.gif"></p><h4 id="ni-j"><a href="#ni-j" class="headerlink" title="ni-j"></a>ni-j</h4><p>   <img src="/images/live2d/ni-j.gif" alt="img"></p><h4 id="nico"><a href="#nico" class="headerlink" title="nico"></a>nico</h4><p>   <img src="/images/live2d/nico.gif" alt="img"></p><h4 id="nietzche"><a href="#nietzche" class="headerlink" title="nietzche"></a>nietzche</h4><p>   <img src="/images/live2d/nietzche.gif" alt="img"></p><h4 id="nipsilon"><a href="#nipsilon" class="headerlink" title="nipsilon"></a>nipsilon</h4><p>   <img src="/images/live2d/nipsilon.gif" alt="img"></p><h4 id="nito"><a href="#nito" class="headerlink" title="nito"></a>nito</h4><p>   <img src="/images/live2d/nito.gif" alt="img"></p><h4 id="shizuku"><a href="#shizuku" class="headerlink" title="shizuku"></a>shizuku</h4><p>   <img src="/images/live2d/shizuku.gif" alt="img"></p><h4 id="tsumiki"><a href="#tsumiki" class="headerlink" title="tsumiki"></a>tsumiki</h4><p>   <img src="/images/live2d/tsumiki.gif" alt="img"></p><h4 id="wanko"><a href="#wanko" class="headerlink" title="wanko"></a>wanko</h4><p>   <img src="/images/live2d/wanko.gif" alt="img"></p><h4 id="z16"><a href="#z16" class="headerlink" title="z16"></a>z16</h4><p>   <img src="/images/live2d/z16.gif" alt="img"></p><h4 id="hibiki"><a href="#hibiki" class="headerlink" title="hibiki"></a>hibiki</h4><p>   <img src="/images/live2d/hibiki.gif" alt="img"></p><h4 id="koharu"><a href="#koharu" class="headerlink" title="koharu"></a>koharu</h4><p>   <img src="/images/live2d/koharu.gif" alt="img"></p><h4 id="haruto"><a href="#haruto" class="headerlink" title="haruto"></a>haruto</h4><p>   <img src="/images/live2d/haruto.gif" alt="img"></p><h4 id="Unitychan"><a href="#Unitychan" class="headerlink" title="Unitychan"></a>Unitychan</h4><p>   <img src="/images/live2d/Unitychan.gif" alt="img"></p><h4 id="tororo"><a href="#tororo" class="headerlink" title="tororo"></a>tororo</h4><p>   <img src="/images/live2d/tororo.gif" alt="img"></p><h4 id="hijiki"><a href="#hijiki" class="headerlink" title="hijiki"></a>hijiki</h4><p>   <img src="/images/live2d/hijiki.gif" alt="img"></p><h2 id="4-安装你自己喜欢的人物对应的模块包"><a href="#4-安装你自己喜欢的人物对应的模块包" class="headerlink" title="4. 安装你自己喜欢的人物对应的模块包"></a>4. 安装你自己喜欢的人物对应的模块包</h2><ol><li><p>模型列表</p><ul><li><code>live2d-widget-model-chitose</code></li><li><code>live2d-widget-model-epsilon2_1</code></li><li><code>live2d-widget-model-gf</code></li><li><code>live2d-widget-model-haru/01</code> (use <code>npm install --save live2d-widget-model-haru</code>)</li><li><code>live2d-widget-model-haru/02</code> (use <code>npm install --save live2d-widget-model-haru</code>)</li><li><code>live2d-widget-model-haruto</code></li><li><code>live2d-widget-model-hibiki</code></li><li><code>live2d-widget-model-hijiki</code></li><li><code>live2d-widget-model-izumi</code></li><li><code>live2d-widget-model-koharu</code></li><li><code>live2d-widget-model-miku</code></li><li><code>live2d-widget-model-ni-j</code></li><li><code>live2d-widget-model-nico</code></li><li><code>live2d-widget-model-nietzsche</code></li><li><code>live2d-widget-model-nipsilon</code></li><li><code>live2d-widget-model-nito</code></li><li><code>live2d-widget-model-shizuku</code></li><li><code>live2d-widget-model-tororo</code></li><li><code>live2d-widget-model-tsumiki</code></li><li><code>live2d-widget-model-unitychan</code></li><li><code>live2d-widget-model-wanko</code></li><li><code>live2d-widget-model-z16</code></li></ul><p>比如我这里选择了<code> hibiki</code>,那么安装命令如下：</p><p>使用使用<code>npm install &#123;packagename&#125;</code>安装模型</p><pre><code class="shell">npm install live2d-widget-model-hibiki</code></pre></li><li><p>这里网上说的是去主题下的<code>_config.yml</code>或者hexo主目录下的<code>_config.yml</code>进行配置，但是我的博客在主题下的<code>_config.yml</code>这样配置后并没有生效，所以我在hexo博客的主目录下的<code>_config.yml</code>文件中进行了如下配置，就可以生效了，将默认的替换成了我自己选择的。</p><pre><code class="typescript"># Live2D## https://github.com/EYHN/hexo-helper-live2d## https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-initlive2d:  enable: true  #enable: false  scriptFrom: local # 默认  pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径)  pluginJsPath: lib/ # 脚本文件相对与插件根目录路径  pluginModelPath: assets/ # 模型文件相对与插件根目录路径  # scriptFrom: jsdelivr # jsdelivr CDN  # scriptFrom: unpkg # unpkg CDN  # scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url  tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中  debug: false # 调试, 是否在控制台输出日志  model:    use: live2d-widget-model-hibiki    # use: live2d-widget-model-wanko # npm-module package name    # use: wanko # 博客根目录/live2d_models/ 下的目录名    # use: ./wives/wanko # 相对于博客根目录的路径    # use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url  display:    position: left    width: 145    height: 315  mobile:    show: true # 是否在移动设备上显示    scale: 0.5 # 移动设备上的缩放         react:    opacityDefault: 0.7    opacityOnHover: 0.8</code></pre></li></ol><h2 id="3-参考文章"><a href="#3-参考文章" class="headerlink" title="3.参考文章"></a>3.参考文章</h2><ul><li><a href="https://joeybling.github.io/2019/05/05/Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0helper-live2d%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9E%8B%E6%8F%92%E4%BB%B6/">Hexo博客添加helper-live2d动态模型插件</a></li><li><a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md">live2d的GitHub文档</a></li><li><a href="https://huaji8.top/post/live2d-plugin-2.0/">hexo live2d插件 2.0 !</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> hexo博客配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> live2D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客优化(转载)</title>
      <link href="/2020/08/13/hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96-%E8%BD%AC%E8%BD%BD/"/>
      <url>/2020/08/13/hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96-%E8%BD%AC%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p><a href="https://hexo.io/zh-cn/">Hexo</a> 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p><ul><li><a href="http://nodejs.org/">Node.js</a> (Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本)</li><li><a href="http://git-scm.com/">Git</a></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><pre><code class="bash">$ npm install -g hexo-cli1</code></pre><p>安装以后，可以使用以下两种方式执行 Hexo：</p><ol><li><p><code>npx hexo</code></p></li><li><p>将 Hexo 所在的目录下的 <code>node_modules</code> 添加到环境变量之中即可直接使用 <code>hexo</code>：</p><pre><code class="bash">echo &#39;PATH=&quot;$PATH:./node_modules/.bin&quot;&#39; &gt;&gt; ~/.profile1</code></pre></li></ol><h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><pre><code class="bash">$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install123</code></pre><p>新建完成后，指定文件夹的目录如下：</p><pre><code class="bash">.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes12345678</code></pre><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>此时，通过 <code>hexo s</code> 命令即可在本地启动您的博客站点了。</p><pre><code class="bash">~ hexo sINFO  Start processingINFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.123</code></pre><p>接下来将安装主题，配置博客托管平台，实现一键发布并刷新CDN缓存。</p><h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><h3 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h3><p><a href="https://github.com/blinkfox/hexo-theme-matery">hexo-theme-matery</a> 是一个采用 <code>Material Design</code> 和响应式设计的 Hexo 博客主题，点击 <a href="https://www.lixl.cn/">这里</a> 可以查看示例效果。点击 <a href="https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master">这里</a> 下载 <code>master</code> 分支的最新稳定版的代码，解压缩后，将 <code>hexo-theme-matery</code> 的文件夹复制到 Hexo 的 <code>themes</code> 文件夹中即可。</p><h3 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h3><p>修改 Hexo 根目录下的 <code>_config.yml</code> 的 <code>theme</code> 的值：<code>theme: hexo-theme-matery</code></p><h4 id="config-yml-文件的其它修改建议"><a href="#config-yml-文件的其它修改建议" class="headerlink" title="_config.yml 文件的其它修改建议:"></a><code>_config.yml</code> 文件的其它修改建议:</h4><ul><li>请修改 <code>_config.yml</code> 的 <code>url</code> 的值为你的网站主 <code>URL</code>（如：<code>http://xxx.github.io</code>）。</li><li>建议修改两个 <code>per_page</code> 的分页条数值为 <code>6</code> 的倍数，如：<code>12</code>、<code>18</code> 等，这样文章列表在各个屏幕下都能较好的显示。</li><li>如果是中文用户，则建议修改 <code>language</code> 的值为 <code>zh-CN</code>。</li></ul><h3 id="新建分类-categories-页"><a href="#新建分类-categories-页" class="headerlink" title="新建分类 categories 页"></a>新建分类 categories 页</h3><p><code>categories</code> 页是用来展示所有分类的页面，如果 <code>source</code> 目录下还没有 <code>categories/index.md</code> 文件，那么就需要新建一个，命令如下：</p><pre><code class="bash">hexo new page &quot;categories&quot;1</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p><pre><code class="yaml">---title: categoriesdate: 2018-09-30 17:25:30type: &quot;categories&quot;layout: &quot;categories&quot;---123456</code></pre><h3 id="新建标签-tags-页"><a href="#新建标签-tags-页" class="headerlink" title="新建标签 tags 页"></a>新建标签 tags 页</h3><p><code>tags</code> 页是用来展示所有标签的页面，如果 <code>source</code> 目录下还没有 <code>tags/index.md</code> 文件，那么就需要新建一个，命令如下：</p><pre><code class="bash">hexo new page &quot;tags&quot;1</code></pre><p>编辑刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p><pre><code class="yaml">---title: tagsdate: 2018-09-30 18:23:38type: &quot;tags&quot;layout: &quot;tags&quot;---123456</code></pre><h3 id="新建关于我-about-页"><a href="#新建关于我-about-页" class="headerlink" title="新建关于我 about 页"></a>新建关于我 about 页</h3><p><code>about</code> 页是用来展示<strong>关于我和我的博客</strong>信息的页面，如果 <code>source</code> 目录下还没有 <code>about/index.md</code> 文件，那么就需要新建一个，命令如下：</p><pre><code class="bash">hexo new page &quot;about&quot;1</code></pre><p>编辑刚刚新建的页面文件 <code>/source/about/index.md</code>，至少需要以下内容：</p><pre><code class="yaml">---title: aboutdate: 2018-09-30 17:25:30type: &quot;about&quot;layout: &quot;about&quot;---123456</code></pre><h3 id="新建友情连接-friends-页（可选的）"><a href="#新建友情连接-friends-页（可选的）" class="headerlink" title="新建友情连接 friends 页（可选的）"></a>新建友情连接 friends 页（可选的）</h3><p><code>friends</code> 页是用来展示<strong>友情连接</strong>信息的页面，如果 <code>source</code> 目录下还没有 <code>friends/index.md</code> 文件，那么就需要新建一个，命令如下：</p><pre><code class="bash">hexo new page &quot;friends&quot;1</code></pre><p>编辑刚刚新建的页面文件 <code>/source/friends/index.md</code>，至少需要以下内容：</p><pre><code class="yaml">---title: friendsdate: 2018-12-12 21:25:30type: &quot;friends&quot;layout: &quot;friends&quot;---123456</code></pre><p>同时，在 <code>source</code> 目录下新建 <code>_data</code> 目录，在 <code>_data</code> 目录中新建 <code>friends.json</code> 文件，文件内容如下所示：</p><pre><code class="json">[&amp;#123;    &quot;avatar&quot;: &quot;https://www.lixl.cn/medias/avatar.jpg&quot;,    &quot;name&quot;: &quot;悟尘记&quot;,    &quot;introduction&quot;: &quot;人生就是一场修行，上善若水，厚德载物。&quot;,    &quot;url&quot;: &quot;https://www.lixl.cn/&quot;,    &quot;title&quot;: &quot;前去参观&quot;&amp;#125;, &amp;#123;    &quot;avatar&quot;: &quot;https://wiki.hyperledger.org/download/attachments/2392069/fabric?version=1&amp;modificationDate=1540928132000&amp;api=v2&quot;,    &quot;name&quot;: &quot;Fabric&quot;,    &quot;introduction&quot;: &quot;A Blockchain Platform for the Enterprise&quot;,    &quot;url&quot;: &quot;https://hyperledger-fabric.readthedocs.io/en/master/&quot;,    &quot;title&quot;: &quot;前去学习&quot;&amp;#125;, &amp;#123;    &quot;avatar&quot;: &quot;https://www.bootcdn.cn/assets/img/maoyun.svg&quot;,    &quot;name&quot;: &quot;BootCDN&quot;,    &quot;introduction&quot;: &quot;稳定、快速、免费的前端开源项目 CDN 加速服务。&quot;,    &quot;url&quot;: &quot;https://www.bootcdn.cn/&quot;,    &quot;title&quot;: &quot;前去加速&quot;&amp;#125;]12345678910111213141516171819</code></pre><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 <a href="https://github.com/ele828/hexo-prism-plugin">hexo-prism-plugin</a> 的 Hexo 插件来做代码高亮，安装命令如下：</p><pre><code class="bash">npm i -S hexo-prism-plugin1</code></pre><p>然后，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并新增 <code>prism</code> 插件相关的配置，主要配置如下：</p><pre><code class="yaml">highlight:  enable: falseprism_plugin:  mode: &#39;preprocess&#39;    # realtime/preprocess  theme: &#39;tomorrow&#39;  line_number: false    # default false  custom_css:12345678</code></pre><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>本主题中还使用到了 <a href="https://github.com/wzpan/hexo-generator-search">hexo-generator-search</a> 的 Hexo 插件来做内容搜索，安装命令如下：</p><pre><code class="bash">npm install hexo-generator-search --save1</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre><code class="yaml">search:  path: search.xml  field: post123</code></pre><h3 id="修改页脚"><a href="#修改页脚" class="headerlink" title="修改页脚"></a>修改页脚</h3><p>页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 <code>/layout/_partial/footer.ejs</code> 文件中，包括站点、使用的主题、访问量等。</p><h3 id="修改社交链接"><a href="#修改社交链接" class="headerlink" title="修改社交链接"></a>修改社交链接</h3><p>在主题的 <code>_config.yml</code> 文件中，默认支持 <code>QQ</code>、<code>GitHub</code> 和邮箱的配置，可以在主题文件的 <code>/layout/_partial/social-link.ejs</code> 文件中，新增、修改需要的社交链接地址，增加链接可参考如下代码：</p><pre><code class="html">&lt;a href=&quot;https://github.com/blinkfox&quot; class=&quot;tooltipped&quot; target=&quot;_blank&quot; data-tooltip=&quot;访问我的GitHub&quot; data-position=&quot;top&quot; data-delay=&quot;50&quot;&gt;    &lt;i class=&quot;fa fa-github&quot;&gt;&lt;/i&gt;&lt;/a&gt;123</code></pre><p>其中，社交图标（如：<code>fa-github</code>）可以在 <a href="https://fontawesome.com/icons">Font Awesome</a> 中搜索找到。以下是常用社交图标的标识，供参考：</p><ul><li>Facebook: <code>fa-facebook</code></li><li>Twitter: <code>fa-twitter</code></li><li>Google-plus: <code>fa-google-plus</code></li><li>Linkedin: <code>fa-linkedin</code></li><li>Tumblr: <code>fa-tumblr</code></li><li>Medium: <code>fa-medium</code></li><li>Slack: <code>fa-slack</code></li><li>新浪微博: <code>fa-weibo</code></li><li>微信: <code>fa-wechat</code></li><li>QQ: <code>fa-qq</code></li></ul><h3 id="修改打赏的二维码图片"><a href="#修改打赏的二维码图片" class="headerlink" title="修改打赏的二维码图片"></a>修改打赏的二维码图片</h3><p>在主题文件的 <code>source/medias/reward</code> 文件中，可以替换成你的的微信和支付宝的打赏二维码图片。</p><h3 id="一键部署"><a href="#一键部署" class="headerlink" title="一键部署"></a>一键部署</h3><p>通过 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a> 插件可以实现一键将博客同时部署到多个git仓库中。如同时发布到github及gitee提供的pages服务。安装：</p><pre><code class="bash">npm install hexo-deployer-git --save1</code></pre><p>修改 Hexo 根目录下的 <code>_config.yml</code> 文件中的如下内容:</p><pre><code class="yaml">## Docs: https://hexo.io/docs/deployment.htmldeploy:  - type: git    repo: https://github.com/lxl80/blog.git    branch: gh-pages    ignore_hidden: false  - type: git    repo: https://gitee.com/lxl80/lxl80.git    branch: master    ignore_hidden: false12345678910</code></pre><blockquote><p>也可以如本站一样，采用 <a href="https://github.com/75k/hexo-deployer-cos-enhanced">hexo-deployer-cos-enhanced</a> 插件将静态内容部署到腾讯云对象存储服务中，在DNS配置中将境内线路解析到腾讯云CDN地址，实现加速。部署完成后会自动刷新被更新文件的CDN缓存。</p></blockquote><p>安装：</p><pre><code class="bash">npm install hexo-deployer-cos-enhanced --save1</code></pre><p><code>_config.yml</code> 配置如下:</p><pre><code class="yaml">deploy:  - type: git    repo: https://github.com/lxl80/blog.git    branch: gh-pages    ignore_hidden: false  - type: cos    bucket: lxl80-130****    region: ap-beijing    secretId: AKIDh9****F8FvL    secretKey: Z3IGiur****QZR3PgjXmlVg    cdnConfig:      enable: true      cdnUrl: https://static.lixl.cn      bucket: static-130****      region: ap-beijing      folder: static      secretId: AKIDh9****F8FvL      secretKey: Z3IGiur****QZR3PgjXmlVg123456789101112131415161718</code></pre><p>然后通过 <code>hexo g -d</code> 即可实现一键发布，并更新CDN缓存。</p><h3 id="文章链接转静态短地址（建议安装）"><a href="#文章链接转静态短地址（建议安装）" class="headerlink" title="文章链接转静态短地址（建议安装）"></a>文章链接转静态短地址（建议安装）</h3><p>如果文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 <code>SEO</code>，且 <code>gitment</code> 评论对中文链接也不支持。我们可以用 <a href="https://github.com/viko16/hexo-permalink-pinyin">hexo-permalink-pinyin</a> Hexo 插件生成文章时生成中文拼音的永久链接，或者用<a href="https://github.com/rozbo/hexo-abbrlink">hexo-abbrlink</a> 生成静态文章链接。以下结合hexo-abbrlink生成类似 <code>/yyyy/mmdd+随机数.html</code> 的文章链接地址。</p><p>安装命令如下：</p><pre><code class="bash">npm install hexo-abbrlink --save1</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，修改 <code>permalink:</code> ，并在文件末尾新增 <code>abbrlink:</code>配置项：</p><pre><code class="yaml">permalink: :year/:month:day:abbrlink.htmlabbrlink:   alg: crc16 #算法选项：crc16丨crc32  rep: dec #输出进制：dec为十进制，hex为十六进制12345</code></pre><h3 id="CND加速（建议启用）"><a href="#CND加速（建议启用）" class="headerlink" title="CND加速（建议启用）"></a>CND加速（建议启用）</h3><p>放在Github的资源在国内加载速度比较慢，因此需要使用CDN加速来优化网站打开速度，<a href="https://www.jsdelivr.com/">jsDelivr</a> + Github便是免费且好用的CDN，非常适合博客网站使用。也可以选择主流云服务商提供的对象存储+CDN来获得更快速及稳定的访问效果，费用低到几乎可忽略。</p><p><strong>用法：</strong></p><pre><code class="http">https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径1</code></pre><p><strong>例如：</strong></p><pre><code class="http">https://cdn.jsdelivr.net/gh/lxl80/blog@gh-pages/medias/banner/1.jpg1</code></pre><p>注意：版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源。</p><blockquote><p>还可以配合 <a href="https://github.com/Molunerfinn/PicGo">PicGo</a>图床上传工具的<strong>自定义域名前缀</strong>来上传图片，使用极其方便。具体使用方法可参见我的另一篇文章: <a href="https://blog.csdn.net/2019/120114500.html">使用Typora+iPic/PicGo图床+CDN实现高效Markdown创作</a></p></blockquote><h3 id="文章字数统计插件（可选的）"><a href="#文章字数统计插件（可选的）" class="headerlink" title="文章字数统计插件（可选的）"></a>文章字数统计插件（可选的）</h3><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 <a href="https://github.com/willin/hexo-wordcount">hexo-wordcount</a>插件。</p><p>安装命令如下：</p><pre><code class="bash">npm i --save hexo-wordcount1</code></pre><p>然后只需在本主题下的 <code>_config.yml</code> 文件中，激活以下配置项即可：</p><pre><code class="yaml">wordCount:  enable: false # 将这个值设置为 true 即可.  postWordCount: true  min2read: true  totalCount: true12345</code></pre><h3 id="添加-RSS-订阅支持（可选的）"><a href="#添加-RSS-订阅支持（可选的）" class="headerlink" title="添加 RSS 订阅支持（可选的）"></a>添加 RSS 订阅支持（可选的）</h3><p>本主题中还使用到了 <a href="https://github.com/hexojs/hexo-generator-feed">hexo-generator-feed</a> 的 Hexo 插件来做 <code>RSS</code>，安装命令如下：</p><pre><code class="bash">npm install hexo-generator-feed --save1</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre><code class="yaml">feed:  type: atom  path: atom.xml  limit: 20  hub:  content:  content_limit: 140  content_limit_delim: &#39; &#39;  order_by: -date123456789</code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后在 <code>public</code> 文件夹中即可看到 <code>atom.xml</code> 文件，说明已经安装成功了。</p><h2 id="自定制修改"><a href="#自定制修改" class="headerlink" title="自定制修改"></a>自定制修改</h2><p>在本主题的 <code>_config.yml</code> 中可以修改部分自定义信息，有以下几个部分：</p><ul><li>菜单</li><li>我的梦想</li><li>首页的音乐播放器和视频播放器配置</li><li>是否显示推荐文章名称和按钮配置</li><li><code>favicon</code> 和 <code>Logo</code></li><li>个人信息</li><li>TOC 目录</li><li>文章打赏信息</li><li>复制文章内容时追加版权信息</li><li>MathJax</li><li>文章字数统计、阅读时长</li><li>点击页面的’爱心’效果</li><li>我的项目</li><li>我的技能</li><li>我的相册</li><li><code>Gitalk</code>、<code>Gitment</code>、<code>Valine</code> 和 <code>disqus</code> 评论配置</li><li><a href="http://busuanzi.ibruce.info/">不蒜子统计</a>和谷歌分析（<code>Google Analytics</code>）</li><li>默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 <code>hashcode</code> 值取余，来选择展示对应的特色图</li></ul><p>如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 <code>_config.yml</code> 中完成，需要修改源代码才来完成。以下列出了可能有用的地方：</p><h3 id="修改主题颜色"><a href="#修改主题颜色" class="headerlink" title="修改主题颜色"></a>修改主题颜色</h3><p>在主题文件的 <code>/source/css/matery.css</code> 文件中，搜索 <code>.bg-color</code> 来修改背景颜色：</p><pre><code class="css">/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */.bg-color &amp;#123;    background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%);&amp;#125;@-webkit-keyframes rainbow &amp;#123;   /* 动态切换背景颜色. */&amp;#125;@keyframes rainbow &amp;#123;    /* 动态切换背景颜色. */&amp;#125;123456789101112</code></pre><h3 id="修改-banner-图和文章特色图"><a href="#修改-banner-图和文章特色图" class="headerlink" title="修改 banner 图和文章特色图"></a>修改 banner 图和文章特色图</h3><p>可以直接在 <code>/source/medias/banner</code> 文件夹中更换喜欢的 <code>banner</code> 图片，主题代码中是每天动态切换一张，只需 <code>7</code> 张即可。如果会 <code>JavaScript</code> 代码，可以修改成自己喜欢切换逻辑，如：随机切换等，<code>banner</code> 切换的代码位置在 <code>/layout/_partial/bg-cover-content.ejs</code> 文件的 <code>&lt;script&gt;&lt;/script&gt;</code> 代码中：</p><pre><code class="javascript">$(&#39;.bg-cover&#39;).css(&#39;background-image&#39;, &#39;url(/medias/banner/&#39; + new Date().getDay() + &#39;.jpg)&#39;);1</code></pre><p>在 <code>/source/medias/featureimages</code> 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 <code>_config.yml</code> 做同步修改。</p><h2 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h2><h3 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图</td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>cover</td><td><code>false</code></td><td>表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td>表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr></tbody></table><blockquote><p><strong>注意</strong>:</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供使用：<a href="http://tool.oschina.net/encrypt?type=2">开源中国在线工具</a>、<a href="http://encode.chahuo.com/">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx">站长工具</a>。</li></ol></blockquote><p>以下为文章的 <code>Front-matter</code> 示例。</p><h3 id="最简示例"><a href="#最简示例" class="headerlink" title="最简示例"></a>最简示例</h3><pre><code class="yaml">---title: 基于Hexo的hexo-theme-matery主题搭建博客并优化date: 2019-10-03 14:25:00---1234</code></pre><h3 id="最全示例"><a href="#最全示例" class="headerlink" title="最全示例"></a>最全示例</h3><pre><code class="yaml">---title: 基于Hexo的hexo-theme-matery主题搭建博客并优化date: 2019-10-03 14:25:00author: 悟尘img: /source/images/xxx.jpgtop: truecover: truecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: 工具tags:  - blog  - hexo---1234567891011121314151617</code></pre><h2 id="SEO优化"><a href="#SEO优化" class="headerlink" title="SEO优化"></a>SEO优化</h2><p>搜索引擎优化，又称为SEO，即Search Engine Optimization，它是一种通过分析搜索引擎的排名规律，了解各种搜索引擎怎样进行搜索、怎样抓取互联网页面、怎样确定特定关键词的搜索结果排名的技术。Google自动收录效果还不错，百度就差得远了（<code>GitHub</code>不允许百度的<code>Spider</code>爬取<code>GitHub</code>上的内容）。</p><h3 id="百度优化"><a href="#百度优化" class="headerlink" title="百度优化"></a>百度优化</h3><p>登录<a href="https://ziyuan.baidu.com/">百度搜索资源平台</a>， 登录成功之后在 用户中心 –&gt; 站点管理 页面中点击<a href="https://ziyuan.baidu.com/site/siteadd">添加网站</a>，按提示操作。</p><p>![](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGl4bC5jbi8yMDIwLzIwMjAwMTI5MjEzMzAyLnBuZy93MTI4MA?x-oss-process=image/format,png">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGl4bC5jbi8yMDIwLzIwMjAwMTI5MjEzMzAyLnBuZy93MTI4MA?x-oss-process=image/format,png</a> =50)</p><blockquote><p>提示：由于百度的spider是爬取不到GitHub的内容的，所以在第三步验证网站的时候，建议选择<code>CNAME验证</code>的方式。</p></blockquote><p>经过以上步骤，百度已经知道有我们网站的存在了，但是百度还不知道我们的网站上有什么内容，所以要向百度推送我们的内容。<code>hexo-theme-matery</code>主题已经内置了 <code>自动推送</code> 的方式， 检查 <code>themes/hexo-theme-matery/_config.yml</code> 文件中如下配置:</p><pre><code class="yaml"># 百度搜索资源平台提交链接baiduPush: true12</code></pre><p>自动推送的JS代码部署在站点的每一个页面源代码中，当页面在每次被浏览时，链接就会被自动推送给百度。</p><h3 id="谷歌优化"><a href="#谷歌优化" class="headerlink" title="谷歌优化"></a>谷歌优化</h3><p>登录 <a href="https://search.google.com/search-console?hl=zh-CN">Google Search Console</a>，点击添加资源，输入自己的域名，按提示操作。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGl4bC5jbi8yMDIwLzIwMjAwMTI5MjE0NzIwLnBuZy93MTI4MA?x-oss-process=image/format,png" alt="img"></p><blockquote><p>提示：需要进行DNS验证，进入DNS域名解析设置页面，按提示增加TXT记录，如下图:<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGl4bC5jbi8yMDIwLzIwMjAwMTI5MjE1MzU4LnBuZy93MTI4MA?x-oss-process=image/format,png" alt="img"></p></blockquote><p>验证成功后，需要提交站点地图。通过安装sitemap插件生成站点地图文件:</p><pre><code class="bash">npm install hexo-generator-sitemap --save npm install hexo-generator-baidu-sitemap --save  #百度专用，可选12</code></pre><p>安装后直接执行 <code>hexo cl&amp;&amp;hexo g -d</code> 命令，就会在网站根目录生成 <code>sitemap.xml</code> 文件。参照下图提交，等待收录。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGl4bC5jbi8yMDIwLzIwMjAwMTI5MjIzMTI0LnBuZy93MTI4MA?x-oss-process=image/format,png" alt="img"></p><blockquote><p>注意：hexo配置文件中的url一定要输入正确的域名，插件是根据url生成站点地图的。</p></blockquote><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="指令说明"><a href="#指令说明" class="headerlink" title="指令说明"></a>指令说明</h3><p><code>hexo server</code> #启动本地服务器，用于预览主题。Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。</p><p><code>hexo server -s</code> #以静态模式启动</p><p><code>hexo server -p 5000</code> #更改访问端口 (默认端口为4000，’ctrl + c’关闭server)</p><p><code>hexo server -i IP地址</code> #自定义 IP</p><p><code>hexo clean</code> #清除缓存 ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹</p><p><code>hexo g</code> #生成静态网页 (执行 $ <code>hexo g</code>后会在站点根目录下生成public文件夹, hexo会将”/blog/source/“ 下面的.md后缀的文件编译为.html后缀的文件,存放在”/blog/public/ “ 路径下)</p><p><code>hexo d</code> #自动生成网站静态文件，并将本地数据部署到设定的仓库(如github)</p><p><code>hexo init</code> 文件夹名称 #初始化XX文件夹名称</p><p><code>npm update hexo -g</code>#升级</p><p><code>npm install hexo -g</code> #安装</p><p><code>node-v</code> #查看node.js版本号</p><p><code>npm -v</code> #查看npm版本号</p><p><code>git --version</code> #查看git版本号</p><p><code>hexo -v</code> #查看hexo版本号</p><h3 id="简写指令"><a href="#简写指令" class="headerlink" title="简写指令"></a>简写指令</h3><pre><code>hexo n &quot;我的第一篇文章&quot;` 等价于 `hexo new &quot;我的第一篇文章&quot;` 还等价于 `hexo new post &quot;我的第一篇文章&quot;hexo p` 等价于 `hexo publishhexo g` 等价于 `hexo generatehexo s`等价于 `hexo serverhexo d` 等价于 `hexo deployhexo g -d`等价于`hexo generate --deploy</code></pre><p>注: <code>hexo clean</code> 没有 简写, <code>git --version</code> 没有简写</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol><li><strong>通过<code>hexo g -d</code>部署时报<code>Error: Spawn failed</code>错误:</strong></li></ol><blockquote><p>这是由于git本地记录的提交版本号与github上不一致导致的，通过<code>git reset --hard commitCode</code>即可解决。</p></blockquote><ul><li><p>检查本地最近提交记录，获取最后一次提交记录的更新时间及标识，如</p><pre><code>280a7fdd46fcfd7d34e652aec15523dcd247fac8</code></pre><pre><code class="bash">cd .deploy_gitcat .git/logs/HEAD    12</code></pre></li><li><p>获取github pages服务所关联分支的最近一次提交记录，获取更新时间及标识。地址一般为：<code>https://github.com/用户名/仓库名/commits/分支名</code>，如<code>https://github.com/lxl80/blog/commits/gh-pages</code></p></li><li><p>如果发现提交最新的提交时间/标识不一致，通过以下命令即可解决:</p><pre><code class="bash">  git reset --hard f085038efdf79546c09641d37b2a2429c1ae8e60 #github上最新的提交标识1</code></pre></li></ul><h2 id="参照"><a href="#参照" class="headerlink" title="参照"></a>参照</h2><ul><li><a href="https://hexo.io/zh-cn/docs/">hexo官方文档</a></li><li><a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/">闪烁之狐</a></li><li><a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">hexo-theme-matery</a></li><li><a href="https://blog.sky03.cn/posts/42790.html#toc-heading-1">Hexo进阶之各种优化</a></li></ul><h2 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h2><p><a href="https://www.lixl.cn/2019/092856736.html">基于Hexo的matery主题搭建博客并深度优化</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo博客配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matery主题优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客文章Front-matter</title>
      <link href="/2020/08/12/hexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0Front-matter/"/>
      <url>/2020/08/12/hexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0Front-matter/</url>
      
        <content type="html"><![CDATA[<h2 id="通用格式"><a href="#通用格式" class="headerlink" title="通用格式"></a>通用格式</h2><p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量，举例来说：</p><pre><code>---title: Hello Worlddate: 2013/7/13 20:46:25---</code></pre><p>以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>layout</code></td><td align="left">布局</td><td align="left"></td></tr><tr><td align="left"><code>title</code></td><td align="left">标题</td><td align="left">文章的文件名</td></tr><tr><td align="left"><code>date</code></td><td align="left">建立日期</td><td align="left">文件建立日期</td></tr><tr><td align="left"><code>updated</code></td><td align="left">更新日期</td><td align="left">文件更新日期</td></tr><tr><td align="left"><code>comments</code></td><td align="left">开启文章的评论功能</td><td align="left">true</td></tr><tr><td align="left"><code>tags</code></td><td align="left">标签（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>categories</code></td><td align="left">分类（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>permalink</code></td><td align="left">覆盖文章网址</td><td align="left"></td></tr></tbody></table><h2 id="matery主题的相关详细格式"><a href="#matery主题的相关详细格式" class="headerlink" title="matery主题的相关详细格式"></a>matery主题的相关详细格式</h2><p>针对本站的matery主题的相关选项介绍</p><pre><code class="markdown">---title: 标题date: 2020-02-29 16:00:00summary: # 文章摘要toc: truemathjax: truetop: truecover: trueabbrlink: 213245 # 自己可随意设置img: &#39;https://img-blog.csdnimg.cn/20200309120551356.png&#39; # 设置文章背景图，设置为外链图片，访问快tags:  - 算法  - 计算机知识categories:  - 算法author: # 设置文章作者password: # 设置密码（yml中开启相应功能）coverImg: # 轮播图片---</code></pre><h2 id="修改创建文章时的固定模板"><a href="#修改创建文章时的固定模板" class="headerlink" title="修改创建文章时的固定模板"></a>修改创建文章时的固定模板</h2><p>一般我们在通过以下命令创建文章时，采用的是默认的模板，我们可以对默认的模板进行修改</p><blockquote><p>hexo new “文章的标题”</p></blockquote><p>修改<code>/scaffolds/post.md</code>文件即可,修改如下</p><pre><code class="markdown">---title: &amp;#123;&amp;#123; title &amp;#125;&amp;#125;date: &amp;#123;&amp;#123; date &amp;#125;&amp;#125;tags:summary:cover:top:img:toc: truemathjax: truecategories:    -tags:    ----</code></pre>]]></content>
      
      
      <categories>
          
          <category> hexo博客配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue项目启动时node_sass报错</title>
      <link href="/2020/08/12/vue%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E6%97%B6%E6%8A%A5%E9%94%99node-sass%E6%8A%A5%E9%94%99/"/>
      <url>/2020/08/12/vue%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E6%97%B6%E6%8A%A5%E9%94%99node-sass%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<h2 id="1、关于vue启动项目时报错"><a href="#1、关于vue启动项目时报错" class="headerlink" title="1、关于vue启动项目时报错"></a>1、关于vue启动项目时报错</h2><p>报错代码如下:</p><pre><code class="shell">npm run dev&gt; hello-vue@1.0.0 dev F:\IDEA\Vue\vue_project\hello-vue&gt; webpack-dev-server --inline --progress --config build/webpack.dev.conf.js 18% building modules 69/75 modules 6 active ...Vue\vue_project\hello-vue\src\App.vue&amp;#123; parser: &quot;babylon&quot; &amp;#125; is deprecated; we now treat it as &amp;#123; parser: &quot;babel&quot; &amp;#125;. 94% asset optimization ERROR  Failed to compile with 1 errors                                                                                                                                                      5:43:54 ├F10: PM┤ error  in ./src/views/Login.vueModule build failed: Error: Missing binding F:\IDEA\Vue\vue_project\hello-vue\node_modules\node-sass\vendor\win32-x64-72\binding.nodeNode Sass could not find a binding for your current environment: Windows 64-bit with Node.js 12.xFound bindings for the following environments:  - Windows 64-bit with Node.js 12.xThis usually happens because your environment has changed since running `npm install`.Run `npm rebuild node-sass` to download the binding for your current environment</code></pre><p>大致的意思是node-sass和node-loader的问题，首先按照提示<code>npm rebuild node-sass</code>进行试着解决问题，但是中途这个node-sass要从GitHub上下载，出现几次网络问题，不能下载。</p><h2 id="2、解决过程"><a href="#2、解决过程" class="headerlink" title="2、解决过程"></a>2、解决过程</h2><h3 id="2-1、看到网上说是node-loader的版本太高的原因"><a href="#2-1、看到网上说是node-loader的版本太高的原因" class="headerlink" title="2.1、看到网上说是node-loader的版本太高的原因"></a>2.1、看到网上说是node-loader的版本太高的原因</h3><ol><li><p>首先去vue项目下的<code>package.json</code>中将node-lodaer的版本修改了下</p><blockquote><p>“sass-loader”: “^7.3.1”,</p></blockquote></li><li><p>然后执行</p><blockquote><p>npm install </p></blockquote><p>然后重新打包项目运行</p><blockquote><p>npm run dev</p></blockquote><p>但是依旧报错</p><pre><code class="shell"> ERROR  Failed to compile with 1 errors                                                                                                                                                      5:43:54 ├F10: PM┤ error  in ./src/views/Login.vueModule build failed: Error: Missing binding F:\IDEA\Vue\vue_project\hello-vue\node_modules\node-sass\vendor\win32-x64-72\binding.nodeNode Sass could not find a binding for your current environment: Windows 64-bit with Node.js 12.x</code></pre><p>说明安装的node-sass并没有安装在当前环境下，但是我去node-modules下的确看到了node-sass模块。令我百思不得其解。</p></li></ol><h3 id="2-2-实际解决方案"><a href="#2-2-实际解决方案" class="headerlink" title="2.2 实际解决方案"></a>2.2 实际解决方案</h3><ol><li><p>首先执行以下安装命令</p><blockquote><p>npm install <a href="mailto:&#x73;&#97;&#115;&#x73;&#45;&#x6c;&#x6f;&#97;&#100;&#x65;&#x72;&#x40;&#55;&#46;&#x33;&#x2e;&#49;">&#x73;&#97;&#115;&#x73;&#45;&#x6c;&#x6f;&#97;&#100;&#x65;&#x72;&#x40;&#55;&#46;&#x33;&#x2e;&#49;</a> –save-dev</p></blockquote></li><li><p>这样会将会安装<code>sass-loader@7.3.1</code>并且将其添加到dev打包的环境下，这样才不会出现上面的在当前环境下找不到sass-loader（但是其实已经安装了），而且这里的sass-loader版本不能太高。</p></li><li><p>再次执行 </p><blockquote><p>npm run dev </p></blockquote><p>项目完美启动，没有报错。</p><p><img src="/images/4.jpg"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反向代理</title>
      <link href="/2020/08/08/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
      <url>/2020/08/08/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>该文章参考了实验室师兄写的教程，并记录了自己在实操过程中的坑。</p><h1 id="1、内网机器配置"><a href="#1、内网机器配置" class="headerlink" title="1、内网机器配置"></a>1、内网机器配置</h1><p>假设现在有一台公用服务器和一台内网服务器，现在想通过反向代理的方式来访问内网服务器。假设公用服务器为A，内网服务器为B。现在将B服务器的22端口绑定到公网服务器A的某一端口P<sub>A</sub>上，那么请求公网的P<sub>A</sub>时，公网服务器就会把请求转发到内网服务器上端口22上。</p><h1 id="2、反向代理"><a href="#2、反向代理" class="headerlink" title="2、反向代理"></a>2、反向代理</h1><p>由于SSH在一段时间没有数据包之后会断开，所以最好直接使用autossh来配置反向代理。<br>（以下操作均在内网进行，而且我采用的是在root账户进行操作）</p><ol><li><p>首先是安装autossh：我在服务器上重装的是Ubuntu18.04，可用以下命令进行安装</p><blockquote><p><strong>apt-get install autossh</strong></p></blockquote></li><li><p>然后添加我们的内网机器的ssh-key到公网以实现自动登陆：**ssh-copy-id &lt;公网机器A的登陆用户名&gt;@&lt;公网机器的ip地址&gt;**。</p><blockquote><p>注意这里的公网机器A的用户名最好不要用root账户来做转发请求，我尝试root账户后发现不能正常反向代理。</p></blockquote></li><li><p>对2的补充，如果本机并没有ssh的key，需要先执行ssh-keygen -t rsa -C “<a href="mailto:&#x79;&#x6f;&#117;&#114;&#95;&#x65;&#x6d;&#x61;&#105;&#x6c;&#x40;&#101;&#x78;&#97;&#109;&#x70;&#108;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">&#x79;&#x6f;&#117;&#114;&#95;&#x65;&#x6d;&#x61;&#105;&#x6c;&#x40;&#101;&#x78;&#97;&#109;&#x70;&#108;&#x65;&#x2e;&#x63;&#x6f;&#x6d;</a>“再进行第二步。</p></li><li><p>利用autossh搭建反向隧道：</p><blockquote><p>autossh -M 55555  -fCNR 2061:localhost:22 &lt;公网机器A的ssh登录用户名&gt;@&lt;公网机器A的IP&gt;</p></blockquote></li><li><p>参数介绍：</p><blockquote><p>​     -f 后台执行ssh指令<br> ​    -C 允许压缩数据<br> ​    -N 不执行远程指令<br> ​    -R 将远程主机（服务器）的某个端口转发到本地机器的指定端口<br> ​    -L 将本地机器（客户机）的某个端口转发到远端指定机器的指定端口<br> ​    -p 指定远程主机的端口<br> ​    -M 添加一个端口用于<strong>心跳包</strong>的发送，该端口只要是服务器上一个可用的未被占用的端口就行。/3、</p></blockquote></li></ol><h1 id="3、设置开机自启动"><a href="#3、设置开机自启动" class="headerlink" title="3、设置开机自启动"></a>3、设置开机自启动</h1><h2 id="3-1-对于Ubuntu16系统"><a href="#3-1-对于Ubuntu16系统" class="headerlink" title="3.1 对于Ubuntu16系统"></a>3.1 对于Ubuntu16系统</h2><p>只需要将上述autossh命令加入到 /etc/rc.local就行。</p><blockquote><p>vim /etc/rc.local</p></blockquote><p>将<b>autossh -M 55555  -fCNR 2061:localhost:22 &lt;公网机器A的ssh登录用户名&gt;@&lt;公网机器A的IP&gt;</b>命令加入到exit 0 之前就行。</p><h2 id="3-2-对于我自己重装的Ubuntu18系统来说"><a href="#3-2-对于我自己重装的Ubuntu18系统来说" class="headerlink" title="3.2 对于我自己重装的Ubuntu18系统来说"></a>3.2 对于我自己重装的Ubuntu18系统来说</h2><p>系统并没有这个文件。</p><p>在网上搜索的结果是Ubuntu18之后采用了新的管理开机自启动的方式。具体自行百度。<br>具体可参考这边知乎文章。<br><a href="https://zhuanlan.zhihu.com/p/63507762">Ubuntu18开机启动脚本</a></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 反向代理 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
